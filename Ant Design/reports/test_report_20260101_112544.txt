================================================================================
TEST EXECUTION REPORT
================================================================================

Start Time: 2026-01-01 11:18:44
End Time: 2026-01-01 11:25:44
Duration: 0:07:00.814780

TOTAL TESTS: 2
PASSED: 1
FAILED: 1
SKIPPED: 0

================================================================================
PASSED TESTS:
================================================================================
1. test_admin_can_successfully_log_in
   File: ..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pytest_bdd\scenario.py
   Line: 266
   Duration: 76.64s

================================================================================
FAILED TESTS:
================================================================================
1. test_admin_can_create_a_new_firm_with_owner
   File: ..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\pytest_bdd\scenario.py
   Line: 266
   Duration: 341.78s
   Error:
fixturefunc = <function step_enter_value_in_field_quoted at 0x000001690B871DA0>
request = <FixtureRequest for <Function test_admin_can_create_a_new_firm_with_owner>>
kwargs = {'context': <conftest.context.<locals>.Context object at 0x000001690B964B60>, 'field_name': 'Postal Code', 'value': '202020'}

    def call_fixture_func(
        fixturefunc: "_FixtureFunc[FixtureValue]", request: FixtureRequest, kwargs
    ) -> FixtureValue:
        if is_generator(fixturefunc):
            fixturefunc = cast(
                Callable[..., Generator[FixtureValue, None, None]], fixturefunc
            )
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
>           fixture_result = fixturefunc(**kwargs)

..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\_pytest\fixtures.py:902: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

context = <conftest.context.<locals>.Context object at 0x000001690B964B60>, value = '202020', field_name = 'Postal Code'

    @when(parsers.parse('I enter "{value}" in the "{field_name}" field'))
    def step_enter_value_in_field_quoted(context, value, field_name):
        """
        Enter a value in a specific field by name (with quoted parameters)
        Automatically detects if field is input or dropdown and handles accordingly
        All values come from the feature file - no hardcoding
        This step is flexible and adapts to UI changes (e.g., if Country changes from dropdown to input)
    
        Args:
            context: Context fixture from conftest.py
            value: Value to enter (from feature file)
            field_name: Name of the field (from feature file)
        """
        print(f"   >> Entering '{value}' in '{field_name}' field...")
    
        # Strip quotes if present
        value = value.strip('"\'')
        field_name = field_name.strip('"\'')
    
        # Try to detect field type dynamically by checking the page
        from selenium.webdriver.common.by import By
        from selenium.common.exceptions import NoSuchElementException
    
        success = False
        field_type_detected = None
    
        # PRIORITY 1: Find data-attr-id FIRST, then determine actual element type
        try:
            from selenium.webdriver.common.by import By
            from selenium.webdriver.support.ui import WebDriverWait
            from selenium.webdriver.support import expected_conditions as EC
    
            # Clear cache for fresh discovery
            context.pattern_discovery.clear_cache()
    
            # Find data-attr-id for the field (try both input and dropdown patterns)
            matching_id = None
            element_type = None
    
            # Try input pattern first
            matching_id = context.pattern_discovery.find_matching_data_attr_id(field_name, 'input')
            if matching_id:
                element_type = 'input'
                print(f"   >> Found data-attr-id for '{field_name}': {matching_id} (as input)")
    
            # If not found as input, try dropdown pattern
            if not matching_id:
                matching_id = context.pattern_discovery.find_matching_data_attr_id(field_name, 'dropdown')
                if matching_id:
                    element_type = 'dropdown'
                    print(f"   >> Found data-attr-id for '{field_name}': {matching_id} (as dropdown)")
    
            # If data-attr-id found, verify actual element type by inspecting the element
            if matching_id:
                try:
                    # Find the actual element by data-attr-id
                    element = context.driver.find_element(By.CSS_SELECTOR, f'[data-attr-id="{matching_id}"]')
    
                    # Determine actual element type by inspecting the element
                    tag_name = element.tag_name.lower()
                    element_class = element.get_attribute('class') or ''
                    element_type_attr = element.get_attribute('type') or ''
    
                    # Check if it's actually an input field
                    is_actual_input = (
                        tag_name == 'input' or
                        'input' in element_class.lower() or
                        element_type_attr in ['text', 'email', 'tel', 'number', 'password']
                    )
    
                    # Check if it's actually a dropdown/select
                    is_actual_dropdown = (
                        tag_name == 'select' or
                        'select' in element_class.lower() or
                        'ant-select' in element_class.lower() or
                        'dropdown' in element_class.lower()
                    )
    
                    # Use actual element type, not the pattern discovery type
                    if is_actual_input:
                        print(f"   >> Element is actually an INPUT field (tag: {tag_name}, class: {element_class[:50]})")
                        success = context.input_handler.fill_input(
                            matching_id,
                            value,
                            identifier_type='data_attr_id'
                        )
                        if success:
                            field_type_detected = 'input'
                            print(f"   >> [OK] Successfully entered '{value}' in '{field_name}' field (via data-attr-id: {matching_id})")
                    elif is_actual_dropdown:
                        print(f"   >> Element is actually a DROPDOWN field (tag: {tag_name}, class: {element_class[:50]})")
                        success = context.dropdown_handler.select_by_text(
                            matching_id,
                            value,
                            identifier_type='data_attr_id'
                        )
                        if success:
                            field_type_detected = 'dropdown'
                            print(f"   >> [OK] Successfully selected '{value}' in '{field_name}' field (via data-attr-id: {matching_id})")
                    else:
                        # Unknown type, try input first
                        print(f"   >> Element type unclear, trying as input first...")
                        success = context.input_handler.fill_input(
                            matching_id,
                            value,
                            identifier_type='data_attr_id'
                        )
                        if success:
                            field_type_detected = 'input'
                            print(f"   >> [OK] Successfully entered '{value}' in '{field_name}' field (via data-attr-id: {matching_id})")
                except Exception as e:
                    print(f"   >> Could not inspect element: {str(e)}")
        except Exception as e:
            print(f"   >> Pattern discovery failed: {str(e)}")
    
        # If pattern discovery didn't work, try both methods sequentially
        if not success:
            # Try input first (most common)
            success = context.input_handler.fill_input(
                field_name,
                value,
                identifier_type='auto'
            )
            if success:
                field_type_detected = 'input'
                print(f"   >> [OK] Successfully entered '{value}' in '{field_name}' field (as input)")
            else:
                # Try dropdown as fallback
                try:
                    success = context.dropdown_handler.select_by_text(
                        field_name,
                        value,
                        identifier_type='auto'
                    )
                    if success:
                        field_type_detected = 'dropdown'
                        print(f"   >> [OK] Successfully selected '{value}' in '{field_name}' field (as dropdown)")
                except Exception as e:
                    # If dropdown fails, try input with label as last resort
                    success = context.input_handler.fill_input(
                        field_name,
                        value,
                        identifier_type='label'
                    )
                    if success:
                        field_type_detected = 'input'
                        print(f"   >> [OK] Successfully entered '{value}' in '{field_name}' field (as input, label fallback)")
    
>       assert success, f"Failed to enter/select '{value}' in '{field_name}' field. Tried both input and dropdown methods."
E       AssertionError: Failed to enter/select '202020' in 'Postal Code' field. Tried both input and dropdown methods.

steps\input_steps.py:888: AssertionError

